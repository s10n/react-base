## TDD 시작하기

### 설계 도구써의 TDD
* 순수함수는 테스트하기 쉽다.
* 입력이 같아도 출력이 같지 않거나, 외부에 입출력해야하는 함수는 테스트하기 어렵다.
  - 예를들면 함수 내부에서 랜덤한 값이나 오늘 날짜를 이용하거나, API에 입출력하는 경우가 그렇다.
  - 하지만 종종 이런 코드들은 불가피하다.
* 이 둘을 분리시키면 테스트가 쉬워진다.
* 즉 자연스럽게 코드의 구조가 좋아진다.

### 사양 정의서로써의 TDD
* 테스트는 코드가 만나는 첫 번째 인터페이스라고 간주할 수 있다.
* 테스트 코드를 먼저 작성하지 않으면, 자칫 잘못된 코드를 작성한 후 잘못된 코드의 동작을 테스트하게 된다.

### 유지보수를 위한 TDD
* 테스트를 잘 작성해둔 코드는 사양을 추가하거나 변경하기에 용이하다.


## 무엇을 테스트해야 하는가?
> [Getting Started with TDD in React](https://semaphoreci.com/community/tutorials/getting-started-with-tdd-in-react)로부터

* 렌더: 컴포넌트가 에러없이 렌더되는지 확인한다.
  - JSX 문법 오류가 없다.
  - 모든 변수가 정의됐다.
  - 렌더 아웃풋이 `null`이 아니다.
* 아웃풋: '렌더되는가' 다음은 '올바르게 렌더되는가'이다.
  - `props`들을 통해 무엇이 출력되길 기대하는가?
* 상태: 모든 조건들을 설명해야 한다.
  - `className`이 조건부라면, 결정하는 로직이 잘 동작하는지 테스트한다.
  - 어떤 하위 요소를 조건부로 렌더한다면, 테스트한다.
* 이벤트: `onClick`, `onChange`에 의해 상호작용 가능한 인풋이나 버튼 컴포넌트라면, 이벤트가 기대한대로 동작하고 특정한 함수를 정확한 `arguments`와 함께 호출하는지 테스트한다.
* 엣지 케이스: 빈 어레이, 1개의 요소만 있는 어레이 등, 상상할 수 있는 모든 엣지 케이스


## 네트워크 I/O
* 내부 함수는 `null`을 전달받지도 않고 반환하지도 않는다고 가정한다.
* 네트워크 I/O에서는 `null`이 들어오면 reject한다.
* 네트워크 I/O 테스트는 느리므로 유닛테스트에 추가하지 않는다. (통합테스트가 필요하다).


## 테스트 더블
* 더미(dummy): 보통 인자 리스트를 채우기 위해 사용되며, 전달은 하지만 실제로 사용되지는 않는다.
* 틀(stub): 더미를 조금 더 구현하여 아직 개발되지 않은 클래스나 메서드가 실제 작동하는 것처럼 보이게 만든 객체로 보통 리턴값은 하드 코딩한다.
* 스파이(spy): 틀과 비슷하지만 내부적으로 기록을 남긴다는 점이 다르다. 특정 객체가 사용되었는지, 예상되는 메서드가 특정한 인자로 호출되었는지 등의 상황을 감시(spying)하고 이러한 정보들을 제공하기도 한다.
* 모의체(fake): 틀에서 조금 더 발전하여 실제로 간단히 구현된 코드를 갖고는 있지만, 운영 환경에서는 사용할 수는 없는 객체다.
* 모형(mock): 더미, 틀, 스파이를 혼합한 형태와 비슷하나 행위를 검증하는 용도로 주로 사용된다.


## 토막상식
* TDD에서 '우연히' 성공하는 테스트는 괜찮다. 앞으로 뭘 테스트할지 확실히 알고 있다면 잘못된 상황은 저절로 바로 잡힌다. TDD 신념을 굽히지 않을 용기를 발휘할 시점이다. 지금 여기서 뭔가 다른 코드가 들어차 있으면 테스트를 앞질러 가버린 셈이다.
  - 코드가 전혀 없어도 좋으니 테스트를 성공시킬 최소한의 코드만 작성하라. 애플리케이션 코드가 테스트보다 앞서 나가면 안 된다.
